---
title: "Technische Details"
description: "Architektur, Speicher, Limits und Runtime-Interna für MineClawd."
---

## Anfrage-Lebenszyklus

1. Du führst `/mclawd ...` oder `/mineclawd prompt ...` aus.
2. MineClawd validiert Provider-Konfiguration und OP-Zugriff.
3. MineClawd lädt oder erstellt den aktiven Session-Status.
4. MineClawd sendet eine Anfrage an einen OpenAI-kompatiblen oder Vertex-Endpunkt.
5. Modellantworten können Tool-Calls auslösen.
6. Tool-Ergebnisse werden in die Modellschleife zurückgeführt.
7. Die finale Assistenten-Ausgabe wird im Chat gerendert und der Session-Verlauf wird gespeichert.

## Runtime-Tool-Familien

- Befehls- und Skriptausführung:
  - `execute-command`
  - `apply-instant-server-script`
- Persistente Skriptdateien:
  - `list-server-scripts`
  - `read-server-script`
  - `write-server-script`
  - `delete-server-script`
  - `reload-game`
  - `sync-command-tree`
- Rückfragen:
  - `ask-user-question`
- Dynamische Platzhalter (nur wenn aktiviert):
  - `list-dynamic-content`
  - `register-dynamic-item`
  - `register-dynamic-block`
  - `register-dynamic-fluid`
  - `update-dynamic-item`
  - `update-dynamic-block`
  - `update-dynamic-fluid`
  - `unregister-dynamic-content`

## Speicherlayout

```text
gameDir/
  config/
    mineclawd.json5
  mineclawd/
    player-settings.json
    sessions/
      <owner>/
        active.json
        <id>.json
    souls/
      default.md
      yuki.md
      <custom>.md
      .active/
        <owner>.txt
  kubejs/
    server_scripts/
      mineclawd/
        ...
```

## Session-Interna

- Session-ID ist ein 4-stelliges Token in Kleinbuchstaben.
- Das Befehls-Token-Format ist `<id>-<title-slug>`.
- Die Session-Datei speichert OpenAI- und Vertex-Verläufe getrennt.
- Der aktive Session-Zeiger wird pro Owner in `active.json` gespeichert.
- Der Session-Titel wird nach der ersten erfolgreichen Runde mit dem Summarize-Modell generiert.

## LLM-Transportdetails

- OpenAI-kompatibler Anfragepfad: `<endpoint>/chat/completions`
- Vertex-Anfragepfad: `<endpoint>/<model>:generateContent?key=<api_key>`
- Beide Pfade verwenden ein Anfrage-Timeout von 60 Sekunden.
- Beide Pfade unterstützen Tool-Calling im Function-Stil.

## Interna dynamischer Platzhalter

- Kapazität: `30` Item-Slots, `30` Block-Slots, `30` Fluid-Slots.
- Feste IDs enthalten:
  - `mineclawd:dynamic_item_001`
  - `mineclawd:dynamic_block_001`
  - `mineclawd:dynamic_fluid_001`
- State-Sync nutzt die Netzwerklast `sync_dynamic_content`.
- State-Persistenz nutzt die Welt-`PersistentState`-ID `mineclawd_dynamic_content`.
- Der Modus `AUTO` aktiviert Runtime-Platzhalter in der Client-Runtime und deaktiviert sie auf dedizierten Servern.

## Netzwerkkanäle

MineClawd definiert diese Paket-Identifikatoren:

- `mineclawd:open_config`
- `mineclawd:sync_broadcast_target`
- `mineclawd:sync_dynamic_content`
- `mineclawd:open_question`
- `mineclawd:question_response`
- `mineclawd:open_history_book`

## Limits und Timer

| Einstellung oder Verhalten | Wert |
| --- | --- |
| Tool-Call-Limit-Bereich | `1` bis `20` |
| Standardwert für Tool-Call-Limit | `16` |
| Standardzustand für Tool-Call-Limit | deaktiviert |
| Maximale Ask-User-Optionen | `5` |
| Ask-User-Timeout | `60` Sekunden |
| TTL für Retry-Token bei fehlgeschlagenen Anfragen | `30` Minuten |
| Anzahl der Rate-Limit-Wiederholungen | `2` Retries |
| Rate-Limit-Retry-Backoff | `1500ms * retry_index` |
| Maximale Verlaufseinträge für Buchaufbau | `300` |

## Sicherheitsmodell

- Jeder Befehlspfad ist OP-geschützt.
- KubeJS-Ausführung ist echte Serverausführung, keine Simulation.
- API-Keys müssen als Geheimnisse behandelt werden.
- Nutze nur vertrauenswürdige Umgebungen.
